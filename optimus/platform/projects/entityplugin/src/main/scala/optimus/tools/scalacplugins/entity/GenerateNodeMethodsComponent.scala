/*
 * Morgan Stanley makes this available to you under the Apache License, Version 2.0 (the "License").
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * See the NOTICE file distributed with this work for additional information regarding copyright ownership.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package optimus.tools.scalacplugins.entity

import optimus.tools.scalacplugins.entity.reporter.OptimusAlarmBuilder1
import optimus.tools.scalacplugins.entity.reporter.OptimusErrors

import scala.tools.nsc.transform.Transform

import scala.tools.nsc.transform.InfoTransform

/**
 * GenerateNodeMethodsComponent identifies methods/vals tagged with Node attachments and generates the relevant async
 * versions of that method. For a method `def foo(i: Int): String`, it will generate:
 *   - def foo$queued(i: Int): Node[String] / PropertyNode[String]
 *   - def foo$newNode(i: Int): Node[String] / PropertyNode[String]
 */
class GenerateNodeMethodsComponent(val plugin: EntityPlugin, val phaseInfo: OptimusPhaseInfo)
    extends EntityPluginComponent
    with Transform
    with InfoTransform
    with SafeTypingTransformers
    with TypedUtils
    with TypedNodeSynthesis
    with WithOptimusPhase {

  import global._

  override protected val transformError: OptimusAlarmBuilder1 = OptimusErrors.GENERATENODES_TRANSFORM_ERROR

  protected def newTransformer(unit: CompilationUnit): TypingTransformer = new GenerateNodeMethodsTransformer(unit)

  private val BackingValAttached = Attached[Attachment.NodeFieldType.BackingVal]
  private val NodeAttached = Attached[Attachment.Node]

  /**
   * GenerateNodeMethods is an info transformer now. The public methods (name$queued, name$newNode) generated by this
   * phase, while (now) invisible to the typechecker, will be called by nodelift, and therefore must already exist by
   * then. However, having moved after typer we've also moved after pickler, so previous runs' efforts in creating these
   * methods are useless to us. This info transformer allows us to add these methods to any class that needs them,
   * irrespective of whether we are currently compiling it.
   */
  object methodGen extends TypeMap {
    def transformDecls(decls0: Scope): List[Symbol] = {
      flatMapConserve(decls0.toList) {
        case node @ NodeAttached(nodeInfo)
            if !nodeMethodsExist(node) && (node.isMethod || node.hasAttachment[Attachment.NodeFieldType.BareVal]) =>
          node :: mkGetNodeSyms(node, nodeInfo)
        case BackingValAttached(_) =>
          // [1] drop backing vals for node vals, since we're using the getter def to generate the node methods.
          // TODO (OPTIMUS-26094): Can we delete this, since these should be stripped out by valaccessors?
          Nil
        case sa: MethodSymbol if sa.isSuperAccessor =>
          // [2] Deferred super accessors methods (super$foo) are generated by scalac's superaccessor phase which runs
          // before this phase. If super$foo is pointing to a node, we need to generate a corresponding
          // super$foo$queued (and if it's a property node also super$foo$newNode) so that optimus_asyncgraph can
          // later rewrite super$foo -> super$foo$queued as usual.
          sa.asMethod.referenced match {
            case NodeAttached(nodeInfo) if !decls0.containsName(mkGetNodeName(sa.name)) =>
              sa.updateAttachment(nodeInfo)
              sa :: mkGetNodeSyms(sa, nodeInfo)
            case _ => sa :: Nil
          }
        case other => other :: Nil
      }
    }

    override def apply(tp: Type): Type = tp match {
      case ClassInfoType(parents0, decls0, sym) if !sym.isJavaDefined =>
        val parents1 = parents0.mapConserve(mapOver)
        val decls1 = transformDecls(decls0)
        // fast path here works because decls0.toList is cached
        if ((parents0 eq parents1) && (decls0.toList eq decls1)) tp
        else ClassInfoType(parents1, newScopeWith(decls1: _*), sym)

      case RefinedType(parents0, decls0) if decls0.nonEmpty =>
        val parents1 = parents0.mapConserve(mapOver)
        assert(parents1 eq parents0, (parents1, parents0))
        val declsList1 = transformDecls(decls0)
        val decls1 = mapOver(if (declsList1 eq decls0.toList) decls0 else newScopeWith(declsList1: _*))
        // playing a little fast+loose here and mutating rt.decls directly
        // since this map only transforms ClassInfoTypes/RefinedTypes (and the former won't ever show up in `parents0`)
        // mapOver(parents0) should always eq parents0, and so we only need to change the scope here. lucky us, decls
        // is mutable, so we can! stuff the new decls into the old scope, and cross your fingers.
        // but why? RefinedTypes happen to be particularly difficult to typemap over, because it's vital that their
        // refinement-only members be called reflectively. But, the check for that is whether the method is declared
        // in its owner's scope! (see `isOnlyRefinementMember`.) So we can't copy the refinement type, or the method
        // would need to be owned by _every_ copy of it, which is of course impossible.
        // An alternative would be to maintain a refinement-class ==>> transformed-type map.
        // (off-topic: why do refined types have parents/decls at all? They have a class with a ClassInfoType. Why not use that?)
        if (decls1 eq decls0) tp
        else {
          decls1.foreach(decls0.enterIfNew)
          tp
        }

      case _ => mapOver(tp)
    }
  }

  override def transformInfo(sym: Symbol, info: Type): Type = methodGen(info)

  class GenerateNodeMethodsTransformer(unit: CompilationUnit) extends SafeTypingTransformer(unit) {

    override def transformSafe(tree: Tree): Tree = tree match {
      case cd @ (_: ClassDef | _: ModuleDef) => atAsyncOffScope(cd)(super.transformSafe(cd))
      case template: Template =>
        deriveTemplate(template) { body =>
          flatMapConserve(body) {
            case NodeAttached(dd: DefDef, nodeInfo) if !nodeMethodsExist(dd.symbol) =>
              val nodeDefs = mkGetNodeDefs(dd, nodeInfo)
              nodeDefs.map(super.transformSafe)
            case NodeAttached(vd: ValDef, nodeInfo)
                if !nodeMethodsExist(vd.symbol) && vd.symbol.hasAttachment[Attachment.NodeFieldType.BareVal] =>
              val nodeDefs = mkGetNodeDefs(vd, nodeInfo)
              nodeDefs.map(super.transformSafe)
            case vd: ValDef if vd.symbol.hasAttachment[Attachment.NodeFieldType.BackingVal] =>
              // see [1] above
              Nil
            case dd: DefDef if dd.symbol.isSuperAccessor =>
              // see [2] above
              dd.symbol.asMethod.referenced match {
                case NodeAttached(nodeInfo) =>
                  val nodeDefs = mkGetNodeDefs(dd, nodeInfo)
                  nodeDefs.map(super.transformSafe)
                case _ => dd :: Nil
              }
            case t =>
              super.transformSafe(t) :: Nil
          }
        }
      case Apply(wrapper, body :: Nil) if wrapper.symbol.name == names.bynameDummy =>
        // this wrapper was added by optimus_classifier. see comment there for rationale
        super.transformSafe(body)
      case _ =>
        val transformed = super.transformSafe(tree)
        transformed.setType(methodGen(transformed.tpe))
    }

  }

  // Note here that we check to ensure a foo$queued method hasn't already been created (eg. by AdjustAST for
  // async lazy methods, or manually (for non-plugin projects such as core))
  // This implies that we shouldn't create any new methods.
  private def nodeMethodsExist(sym: Symbol): Boolean =
    sym.owner.info.decls.lookupAll(mkGetNodeName(sym.name)).exists { s =>
      s.tpe.matches(methodType(sym.tpe, NodeFuture, NoSymbol)) ||
      s.tpe.matches(methodType(sym.tpe, Node, NoSymbol))
    }
}
