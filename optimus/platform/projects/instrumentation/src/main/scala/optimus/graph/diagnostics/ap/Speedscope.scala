/*
 * Morgan Stanley makes this available to you under the Apache License, Version 2.0 (the "License").
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * See the NOTICE file distributed with this work for additional information regarding copyright ownership.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package optimus.graph.diagnostics.ap

import optimus.platform.util.Log

import java.io.BufferedWriter
import java.io.FileWriter
import java.util
import scala.collection.mutable
import scala.collection.mutable.ArrayBuffer
import scala.jdk.CollectionConverters._

object Speedscope {
  final case class Trace(value: Long, stack: Array[Int])

  implicit def asPair(t: Trace): (Long, Array[Int]) = (t.value, t.stack) // so unzip works
}

class Speedscope(cleanLambdas: Boolean) extends Log {
  import Speedscope._
  import StackAnalysis._
  private val frameNameToIndex = mutable.HashMap.empty[String, Int]
  private val allFrames = mutable.ArrayBuffer.empty[String]
  allFrames += "root"
  private val profiles = mutable.HashMap.empty[String, ArrayBuffer[Trace]]

  def frames(frameIds: Iterable[Int]): Iterable[String] = frameIds.map(allFrames.apply)
  def line(frameIds: Iterable[Int], weight: Long): String = frames(frameIds).mkString("", ";", s" $weight")

  def snap: (IndexedSeq[String], Map[String, Iterable[Trace]]) = synchronized {
    (
      allFrames.clone(),
      profiles.map { case (pname, traces) =>
        pname -> traces.clone()
      }.toMap)
  }

  /**
   * Get integer id for this method name, adding to dictionary if necessary.
   */
  def methodIndex(name0: String): Int = synchronized {
    // Won't be necessary if names were generated by a recent version of sampling profiler
    val name =
      if (cleanLambdas && name0.contains(lambdaPrefixSearch)) lambdaRe.replaceAllIn(name0, lambdaSubstitute) else name0
    frameNameToIndex.getOrElseUpdate(
      name, {
        allFrames += name
        allFrames.size - 1
      })
  }
  def addTrace(eventType: String, value: Long, trace: Array[Int]): Unit = synchronized {
    val profile = profiles.getOrElseUpdate(eventType, ArrayBuffer.empty)
    profile += Trace(value, trace)
  }

  /**
   * Top methods for each profile by total and self value
   */
  private def topValues(n: Int): Map[String, Map[String, Seq[(Long, String)]]] = {
    val (allFrames, profiles) = snap
    def top(contribs: util.HashMap[Int, Long]): Seq[(Long, String)] =
      contribs.asScala.toSeq.sortBy(-_._2).take(n).map { case (id, v) =>
        v -> allFrames(id)
      }
    profiles.map { case (profile, traces) =>
      val totalTimes = new util.HashMap[Int, Long]()
      val selfTimes = new util.HashMap[Int, Long]()
      traces.foreach { trace =>
        selfTimes.compute(trace.stack.last, (_, st) => if (st eq null) trace.value else st + trace.value)
        trace.stack.distinct.foreach { id =>
          totalTimes.compute(id, (_, tt) => if (tt eq null) trace.value else tt + trace.value)
        }
      }
      profile -> Map("total" -> top(totalTimes), "self" -> top(selfTimes))
    }
  }

  def writeSummary(n: Int, outputFile: String): Unit = {
    import spray.json._
    import spray.json.DefaultJsonProtocol._
    log.info(s"Writing summary JSON to $outputFile")
    val cumu = topValues(n)
    val output = new BufferedWriter(new FileWriter(outputFile))
    val json = cumu.toJson.prettyPrint
    output.write(json)
    output.close()
  }

  /*
    From https://github.com/jlfwong/speedscope/blob/main/sample/profiles/speedscope/0.1.2/simple-sampled.speedscope.json
    {
          "version": "0.1.2",
          "$schema": "https://www.speedscope.app/file-format-schema.json",
          "profiles": [
            {
  "type": "sampled",
    "name": "simple.speedscope.json",
    "unit": "seconds",
    "startValue": 0,
    "endValue": 14,
          "samples": [[0, 1, 2], [0, 1, 2], [0, 1, 3], [0, 1, 2], [0, 1]],
          "weights": [1, 1, 4, 3, 5]
        }
      ],
      "shared": {
        "frames": [{"name": "a"}, {"name": "b"}, {"name": "c"}, {"name": "d"}]
      }
    }
   */

  def write(outputFile: String): Unit = {
    val (allFrames, profiles) = snap
    val output = new BufferedWriter(new FileWriter(outputFile))
    val dollar = "$"
    def frameElement(frame: String) = s"""{"name":"$frame"}"""
    def vecString(xs: Iterable[_]) = xs.mkString("[", ",", "]")
    def vecStringCR(xs: Iterable[_]) = xs.mkString("[\n", ",\n", "\n]")

    log.info(s"Read ${profiles.map(_._2.size).sum} stacks, with ${allFrames.size} unique frames")
    log.info(s"Writing JSON to $outputFile")

    output.write(s"""{
  "version": "0.1.2",
  "${dollar}schema": "https://www.speedscope.app/file-format-schema.json",
  "shared" : {
     "frames" : ${vecString(allFrames.map(frameElement))}
  },
  "profiles" : ${vecStringCR(profiles.map { case (pname, profile) =>
        val (weights: Iterable[Long], traces: Iterable[Array[Int]]) = profile.unzip
        s"""{
    "type": "sampled",
     "name": "$pname",
     "unit": "none",
     "startValue": 0,
     "endValue": 100,
     "samples" : ${vecStringCR(traces.map(vecString(_)))},
     "weights" : ${vecString(weights)}
   }"""
      }) /* end profiles */}
  }""")

    output.flush()
    output.close()
  }
}
