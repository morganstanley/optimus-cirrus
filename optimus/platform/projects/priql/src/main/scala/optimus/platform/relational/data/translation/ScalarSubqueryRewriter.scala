/*
 * Morgan Stanley makes this available to you under the Apache License, Version 2.0 (the "License").
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * See the NOTICE file distributed with this work for additional information regarding copyright ownership.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package optimus.platform.relational.data.translation

import optimus.platform.Query
import optimus.platform.relational.data.language.QueryLanguage
import optimus.platform.relational.data.tree._
import optimus.platform.relational.tree._

class ScalarSubqueryRewriter protected (language: QueryLanguage) extends DbQueryTreeVisitor {
  private[this] var currentFrom: RelationElement = _

  override protected def handleSelect(select: SelectElement): RelationElement = {
    val saveFrom = currentFrom
    currentFrom = visitSource(select.from)

    val where = visitElement(select.where)
    val orderBy = visitOrderBy(select.orderBy)
    val groupBy = visitElementList(select.groupBy)
    val skip = visitElement(select.skip)
    val take = visitElement(select.take)
    val columns = visitColumnDeclarations(select.columns)

    val s = updateSelect(select, currentFrom, where, orderBy, groupBy, skip, take, columns)
    currentFrom = saveFrom
    s
  }

  override protected def handleScalar(scalar: ScalarElement): RelationElement = {
    import DbQueryTreeComparer._

    val sel = scalar.select
    val selHasGroupBy = (sel.groupBy ne null) && sel.groupBy.nonEmpty
    val resOpt = currentFrom match {
      case curFrm: SelectElement
          if curFrm.groupBy != null && curFrm.groupBy.nonEmpty && !selHasGroupBy && sel.where != null && areEqual(
            sel.from,
            curFrm.from) =>
        val aliasScope = new ScopedHashMap[TableAlias, TableAlias](null)
        mapAliases(sel.from, curFrm.from, aliasScope)

        // check if where condition contains all items in groupBy
        val conditions = Query.flattenBOOLANDConditions(sel.where)
        if (conditions.size < curFrm.groupBy.size) None
        else {
          // here we have the assumption that the where generated by bindGroupBy method won't break the order
          val (selWhere, grpWhere) = conditions.splitAt(conditions.length - curFrm.groupBy.size)
          val grpWhereGood = grpWhere.zip(curFrm.groupBy).forall { case (cond, grpKey) =>
            val leftRightOption = cond match {
              case BinaryExpressionElement(BinaryExpressionType.EQ, l, c: ColumnElement, _)
                  if c.columnInfo == ColumnInfo.Calculated && (c.alias eq curFrm.alias) =>
                curFrm.columns.find(_.name == c.name).map(_.element).map(r => l -> r)
              case BinaryExpressionElement(BinaryExpressionType.EQ, l, OptionElement(c: ColumnElement), _)
                  if c.columnInfo == ColumnInfo.Calculated && (c.alias eq curFrm.alias) =>
                curFrm.columns.find(_.name == c.name).map(_.element).map(r => l -> OptionElement(r))
              case BinaryExpressionElement(BinaryExpressionType.EQ, l, r, _) =>
                Some(l -> r)
              case _ => None
            }
            leftRightOption map { case (left, right) =>
              areEqual(null, aliasScope, left, grpKey) &&
              areStructureEqual(left, right) &&
              !areEqual(left, right)
            } getOrElse false
          }
          if (!grpWhereGood) None
          else {
            val curFrmWhere = Query.flattenBOOLANDConditions(curFrm.where)
            val sa = new SelectElement(
              sel.alias,
              Nil,
              sel.from,
              null,
              sel.orderBy,
              selWhere,
              sel.skip,
              sel.take,
              sel.isDistinct,
              sel.reverse)
            val sb = new SelectElement(
              curFrm.alias,
              Nil,
              curFrm.from,
              null,
              curFrm.orderBy,
              curFrmWhere,
              curFrm.skip,
              curFrm.take,
              curFrm.isDistinct,
              curFrm.reverse)
            if (areEqual(sa, sb)) {
              // replace Scalar with a ColumnElement; put the aggregate into curFrm
              val name = ColumnDeclaration.getAvailableColumnName(curFrm.columns, "scalar")
              val aggElem = AliasReplacer.replace(sel.columns(0).element, aliasScope)
              val colDecl = ColumnDeclaration(name, aggElem)
              currentFrom = new SelectElement(
                curFrm.alias,
                curFrm.columns.:+(colDecl),
                curFrm.from,
                curFrm.where,
                curFrm.orderBy,
                curFrm.groupBy,
                curFrm.skip,
                curFrm.take,
                curFrm.isDistinct,
                curFrm.reverse
              )
              Some(new ColumnElement(aggElem.rowTypeInfo, curFrm.alias, name, ColumnInfo.Calculated))
            } else None
          }
        }
      case _ => None
    }
    resOpt.getOrElse(super.handleScalar(scalar))
  }

  private def mapAliases(
      a: RelationElement,
      b: RelationElement,
      aliasScope: ScopedHashMap[TableAlias, TableAlias]): Unit = {
    val prodA = DeclaredAliasGatherer.gather(a)
    val prodB = DeclaredAliasGatherer.gather(b)
    for ((a1, a2) <- prodA.zip(prodB)) {
      aliasScope.put(a1, a2)
    }
  }
}

object ScalarSubqueryRewriter {
  def rewrite(language: QueryLanguage, e: RelationElement): RelationElement = {
    new ScalarSubqueryRewriter(language).visitElement(e)
  }
}

private class AliasReplacer(map: ScopedHashMap[TableAlias, TableAlias]) extends DbQueryTreeVisitor {
  override def handleColumn(column: ColumnElement): RelationElement = {
    val mapped = map.getOrElse(column.alias, null)
    if (mapped eq null) column else new ColumnElement(column.rowTypeInfo, mapped, column.name, column.columnInfo)
  }
}

object AliasReplacer {
  def replace(e: RelationElement, map: ScopedHashMap[TableAlias, TableAlias]): RelationElement = {
    new AliasReplacer(map).visitElement(e)
  }

  def replace(e: RelationElement, oldAlias: TableAlias, newAlias: TableAlias): RelationElement = {
    val map = new ScopedHashMap[TableAlias, TableAlias](null)
    map.put(oldAlias, newAlias)
    replace(e, map)
  }
}
