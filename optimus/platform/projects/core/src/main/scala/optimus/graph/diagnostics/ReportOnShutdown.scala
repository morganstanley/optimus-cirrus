/*
 * Morgan Stanley makes this available to you under the Apache License, Version 2.0 (the "License").
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * See the NOTICE file distributed with this work for additional information regarding copyright ownership.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package optimus.graph.diagnostics
import optimus.core.config.StaticConfig
import optimus.graph.OGTrace
import optimus.graph.diagnostics.gridprofiler.CSVResultsExtractor
import optimus.graph.diagnostics.gridprofiler.GridProfiler
import optimus.graph.diagnostics.gridprofiler.GridProfiler.ProfilerOutputStrings.ogtraceExtension
import optimus.graph.diagnostics.gridprofiler.GridProfiler.writeAppletNameCsv
import optimus.graph.diagnostics.gridprofiler.GridProfilerUtils._
import optimus.graph.diagnostics.gridprofiler.Level
import optimus.graph.diagnostics.rtverifier.RTVerifierReporter

import java.io.PrintWriter
import java.io.StringWriter
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import scala.util.control.NonFatal

/**
 * On shutdown, write reports and send crumbs on the collected data
 */
private[optimus] object ReportOnShutdown {
  private var registered: Boolean = _
  private val appletNames = scala.collection.mutable.Set[String]()

  def register(suppliedDir: String): Unit = synchronized {
    if (!registered) {
      registered = true
      sys.addShutdownHook(Report.writeReportsAndCrumbs(suppliedDir))
    }
  }

  def registerAppletInfo(appletNameToBeAppended: String): Unit = synchronized {
    if (GridProfiler.getDefaultLevel != Level.NONE) {
      appletNames += appletNameToBeAppended
      sys.addShutdownHook(writeAppletNameCsv(appletNames.toSet))
    }
  }
}

private[optimus] object Report {

  private[diagnostics] def writeReportsAndCrumbs(suppliedDir: String): Unit = {
    val fileStamp = reportUniqueName
    val csvDir = reportCSVFolder(suppliedDir)

    sendSummaryCrumb()
    writePgoData(fileStamp)

    csvDir.foreach { dir =>
      Files.createDirectories(dir)

      writeCSVFilesAndCrumbs(dir, fileStamp, defaultCSVResultsExtractor)
      writeOGTrace(dir, fileStamp)
      writeDiagnostics(dir, fileStamp)
    }

    writeHtmlReport(csvDir, fileStamp)
  }

  def writeCSVFilesAndCrumbs(dir: Path, prefix: String, csvExtractor: CSVResultsExtractor): Unit = {
    def write(suffix: String, data: Option[String]): Unit = data.foreach {
      writeToFile(dir.resolve(s"$prefix.$suffix"), _)
    }

    sendCSVResultCrumb(csvExtractor.csvRes)

    write("summary_table_raw.json", summaryTableContent)
    write("profiler_dalStats.csv", csvExtractor.dalStatsContent)
    // don't change the name of this file or else corresponding env pr is needed to change performance_metrics.py which
    // expects this name
    write("profiler_customCounters.csv", csvExtractor.customCountersNonPriqlContent)
    write("profiler_customCountersPriql.csv", csvExtractor.customCountersPriqlContent)
    write("profiler_syncStacks.txt", csvExtractor.syncStacksContent)
    write("profiler_vtTtStacks.csv", csvExtractor.vtTtStacksContent)
    write("profiler_stallTimes.csv", csvExtractor.stallTimesContent)
    write("profiler_environ.csv", csvExtractor.environMetricsContent)
    write("profiler_threads.csv", csvExtractor.threadStatsContent)
    write(s"$hotspotsFileName.csv", hotspotsContent)
    write("explain_pgo_decision.csv", pgoDecisionContent)
    write("crumbstats.json", crumbStats)
  }

  // write anything collected based on local OGTrace mode, and local + remote hotspots
  private def writeOGTrace(dir: Path, prefix: String): Unit = {
    hotspotsSummary.foreach { hotspots =>
      val ogTraceFile = dir.resolve(s"$prefix.$ogtraceExtension")
      // alternatively: if current trace mode collects hotspots but doesn't write directly to trace, we could just
      // flush collected data to the file, but that would be missing remote hotspots collected by GridProfiler
      OGTrace.writeHotspotsTo(ogTraceFile.toString, hotspots)
      writeAutogeneratedPgoData(dir, prefix)
    }
  }

  private def writeHtmlReport(rootDir: Option[Path], prefix: String): Unit = {
    val baseDir = rootDir.getOrElse {
      // include username in case of permission denied
      def tmpDir =
        Paths.get(sys.props("java.io.tmpdir")).resolve(sys.props("user.name")).resolve("logs/profiler").toAbsolutePath
      Files.createDirectories(tmpDir)
      tmpDir
    }
    val htmlReportDir = baseDir.resolve("html-report").resolve(prefix).normalize()
    writeHtmlReport(htmlReportDir)
  }

  private def writeHtmlReport(dir: Path): Unit = {
    // this is hardcoded to match the js resources we request to load in gridprofiler.html
    val prefix = "gridprofiler"

    def write(filename: String, data: Option[String]): Unit = data.foreach {
      writeToFile(dir.resolve(filename), _)
    }

    val htmlResources = "html" :: "css" :: "js" :: Nil
    htmlResources.foreach { resource =>
      copyFileFromResources(dir.resolve(s"$prefix.$resource"), s"/$resource/$prefix.$resource")
    }

    // hard-coded data that contains each rt violation category and the description to use in the report
    val rtvDir = StaticConfig.string("rtvDir")
    val rtvCategoriesFile = s"$rtvDir${prefix}_rtv_categories.js"
    copyFileFromResources(dir.resolve(rtvCategoriesFile), s"/js/$rtvCategoriesFile")

    write(s"${prefix}_result.js", gridProfilerJsContent)
    write(s"${prefix}_result_lc.js", lostCCJsContent)
    write(s"${prefix}_result_hotspots.js", hotspotsJsContent)
    write(s"${prefix}_result_rtv.js", RTVerifierReporter.rtViolationsContent)
    val htmlLocation = dir.resolve(prefix).toString.replace('\\', '/')
    logToConsole(s"See profiling report at file:///$htmlLocation.html")
  }

  private def writeDiagnostics(dir: Path, prefix: String): Unit = {
    def write(suffix: String, data: Option[String]): Unit = data.foreach {
      writeToFile(dir.resolve(s"$prefix.$suffix"), _)
    }

    write("all_sync_stacks.json", lostCCContent)

    write("opened_files.txt", openFilesContent)
    sendOpenFilesCrumb()

    write("opened_connections.txt", openConnectionsContent)
    sendOpenConnectionsCrumb()
  }

  private def writeToFile(path: Path, contents: String): Unit = {
    val absolutePath = path.toAbsolutePath
    try {
      Files.write(absolutePath, contents.getBytes)
      logToConsole(s"[INFO] Wrote profiling data at $absolutePath")
    } catch {
      case NonFatal(ex) =>
        logToConsole(s"[WARN] Could not write file at $absolutePath", Some(ex))
    }
  }

  // [IMPORTANT] We cannot use a proper logger here as this is executed in a shutdown hook:
  // it's very possible that loggers may have already been shut down at this point.
  private def logToConsole(msg: String, cause: Option[Throwable] = None): Unit = {
    val stackTrace = cause.fold("") { ex =>
      val sw = new StringWriter()
      val pw = new PrintWriter(sw)
      try {
        ex.printStackTrace(pw)
        s"Caused by ${sw.toString}"
      } finally pw.close()
    }
    println(s"$msg $stackTrace")
  }

}
