/*
 * Morgan Stanley makes this available to you under the Apache License, Version 2.0 (the "License").
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * See the NOTICE file distributed with this work for additional information regarding copyright ownership.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package optimus.platform.storable

import java.nio.ByteBuffer
import java.util.Arrays
import java.util.UUID
import java.util.concurrent.atomic.AtomicInteger
import com.eaio.uuid.UUIDGen
import com.google.common.hash.Hashing
import com.google.common.primitives.Longs
import net.iharder.Base64
import optimus.exceptions.RTExceptionTrait
import optimus.graph.DiagnosticSettings

import scala.annotation.tailrec
import scala.util.Random
import scala.util.hashing.MurmurHash3

object UUIDGenerator {
  private val disableCustomUuidLayout =
    DiagnosticSettings.getBoolProperty("optimus.platform.storable.disableCustomUuidLayout", false)

  /**
   * Returns the first 8 bytes of all UUIDs to be generated within this process. NB this portion is fixed for all UUIDs
   * within the process.
   *
   * The `pid` value supplied should correspond to the local process ID. This will be used modulo `2^16^`. NB if the
   * supplied pid is not a positive number greater than zero, a pseudorandom value will be used instead.
   *
   * The `clockSeqAndNode` value should be a long with the same layout of data as [[UUIDGen.getClockSeqAndNode]]:
   *   - The first two bytes are pseudorandom
   *   - The remaining six bytes are the MAC address NB per RFC 4122, one nibble in this value corresponds to the UUID
   *     version number. If a hardware MAC address is not available, a pseudorandom value can be used instead.
   *
   * @param pid
   *   the process ID
   * @param clockSeqAndNode
   *   eight bytes of process-local data
   * @return
   *   the fixed portion to be used at the start of UUIDs generated by this process
   */
  private[optimus] def fixedPortion(pid: Long, clockSeqAndNode: Long): Array[Byte] = {
    // For our layout the first two bytes represent the pid. If for some reason we did not get a positive value, we
    // generate a random long instead. Since we only have two bytes we take the value modulo 2^16
    val pidPortion = {
      val _pid = if (pid <= 0) Random.nextLong() else pid
      (_pid & 65535) << 48
    }

    // Bytes three and four are pseudorandom. clockSeqAndNode already has random bytes in positions 1 and 2 which we
    // can reuse.
    val randomPortion = (clockSeqAndNode >> 16) & 0x0000ffff00000000L

    // The basis for the last four bytes is the MAC address. The entire MAC address is 6 bytes -- three OU bytes and
    // three NIC-specific bytes. We take the least significant four bytes of this. clockSeqAndNode has these values in
    // the same position as we want them so we don't need to do any shifting, just mask away the bits we don't want.
    // NB RFC 4122 states that the UUID version should live as a nibble at bit positions 48-51. The `clockSeqAndNode`
    // value here is also zero-ed out and replaced with the value `e` as this is the version number we use for this
    // UUID layout.
    val macPortion = (clockSeqAndNode & 0x00000000ffff0fffL) | 0x000000000000e000L

    Longs.toByteArray(pidPortion | randomPortion | macPortion)
  }

  private val firstEightBytes = fixedPortion(ProcessHandle.current.pid, UUIDGen.getClockSeqAndNode)

  // The first 8 bytes of the UUID are fixed for all UUIDs in this process and are held in this val
  private[this] def append(out: Array[Byte], in: Long, _offset: Int, length: Int): Int = {
    var offset = _offset
    var lim = (length << 3) - 8
    while (lim >= 0) {
      out(offset) = ((in >> lim) & 0xff).asInstanceOf[Byte]
      lim -= 8
      offset += 1
    }
    offset
  }

  /**
   * A UUID with a custom layout to minimize collisions.
   *
   * UUIDs are 128 bits (two longs) and this layout is designed to minimize collisions both within a single process and
   * between different processes.
   *
   * The layout is as follows:
   * {{{
   * 0-7 8-15 16-23 24-31
   * \+---------+---------+---------+---------+ 0 | p | p | r | r |
   * \+---------+---------+---------+---------+ 1 | m | m | V | m | m |
   * \+---------+---------+---------+---------+ 2 | W | t | t | t | t |
   * \+---------+---------+---------+---------+ 3 | t | t | t | t |
   * \+---------+---------+---------+---------+
   *
   * pppprrrr-mmmm-Vmmm-tttt-tttttttttttt
   * }}}
   * where
   *
   * `p` is the process ID of the process, modulo 65536 `r` is a 16-bit pseudo-random number `m` is the
   * least-significant four bytes of the MAC address, i.e. one OU byte and three NIC-specific bytes `V` is the UUID
   * version nibble -- `e` in our case `W` is the version variant marker. Per RFC 4122 we use the value `a` for variant
   * 1 `t` is the milli-precision system clock time, de-duplicated within a process by incrementing it on collision
   *
   * We include the PID in order to reduce the chance of collision between two processes on the same box. A portion of
   * the MAC address is used to reduce the chance of collision between processes across machines (for this reason, we
   * favour the NIC-specific bytes of the MAC address rather than the OU bytes).
   *
   * We need some random portion in order to reduce the chances of collision in environments where both MAC and PID
   * might collide. For example, in container environments, two containers being run on the same physical host and using
   * host networking mode might share the same MAC address. It's possible that processes in these two containers might
   * also share PID space and so that PIDs may collide. The random portion reduces the probability of collision in the
   * first 64 bits of the UUID to `2^-16^`.
   *
   * The Version and Variant fields are described in [[https://datatracker.ietf.org/doc/html/rfc4122 RFC 4122]]. We use
   * a version value of `e` because it's not one of the pre-defined version numbers and because it isn't `f`, which
   * feels like it might at some point become a reserved value. We describe our UUIDs as variant `1` using the binary
   * value `0b10xx`.
   *
   * NB the implementation of [[UUIDGen.newTime]] already produces the entire second half of the UUID for us, and does
   * the work of guaranteeing that one process does not produce duplicate time portions no matter how often UUIDs are
   * generated.
   *
   * It is possible for collisions to arise in these UUIDs, as follows:
   *
   *   - the PID portion would need to match. This means that either the PIDs collide when taken modulo `2^16^` or that
   *     the PID was unavailable and that the pseudorandom number generated in its place collides.
   *   - the pseudorandom portion would need to match. This is process-local but could collide across processes.
   *   - the MAC address portion would need to match, meaning that either the MAC address is the same (e.g. two
   *     processes on the same machine) or that it was unavailable and the random number used instead collides.
   *   - the time portion would need to match. This is almost guaranteed to remain unique within a process, although it
   *     is possible that a single process might assign enough UUIDs that it wraps around the upper bound value and
   *     eventually catches itself up from the lower bound value.
   *
   * @return
   *   a fresh UUID according to the layout given above.
   */
  private[optimus] def freshUuid(): Array[Byte] = {
    import com.eaio.uuid.UUIDGen._ // not using `new UUID` because of pointless CORBA dependency
    val out = new Array[Byte](16)

    if (disableCustomUuidLayout) {
      var offset: Int = 0
      offset = append(out, (getClockSeqAndNode >> 48).asInstanceOf[Short], offset, 2)
      offset = append(out, getClockSeqAndNode, offset, 6)
      offset = append(out, newTime(), offset, 8)
    } else {
      System.arraycopy(firstEightBytes, 0, out, 0, firstEightBytes.length)
      append(out, newTime(), firstEightBytes.length, 8)
    }
    out
  }
}

object UUIDConversions {
  def uuidToBytes(uuid: UUID): Array[Byte] = {
    val bb = ByteBuffer.allocate(16)
    bb.putLong(uuid.getLeastSignificantBits)
    bb.putLong(uuid.getMostSignificantBits)
    bb.array
  }

  def bytesToUUID(bytes: Array[Byte]): UUID = {
    val bb = ByteBuffer.wrap(bytes)
    val lsb = bb.getLong()
    val msb = bb.getLong()
    new UUID(msb, lsb)
  }
}

object RawReference {
  def uuidToBytes(uuid: UUID): Array[Byte] = UUIDConversions.uuidToBytes(uuid)
  private[optimus] def stringToBytes(rep: String): Array[Byte] = Base64.decode(rep, Base64.DONT_GUNZIP)
  private val hashing = Hashing.murmur3_128()

  /**
   * To be in line with how mongo and PG sort, this ordering sorts references as arrays of unsigned bytes
   */
  implicit def ordering[T <: RawReference]: Ordering[T] = new Ordering[T] {
    override def compare(x: T, y: T): Int = {
      def checkLength(ref: T): Unit =
        require(ref.data.length == 16, s"entity references should be 16 bytes, $ref is ${ref.data.length} bytes")
      checkLength(x)
      checkLength(y)

      @tailrec def sort(i: Int): Int = {
        def toUnsigned(b: Byte) = (b + 128).toByte
        if (i == 16) 0
        else
          toUnsigned(x.data(i)).compareTo(toUnsigned(y.data(i))) match {
            case 0 => sort(i + 1)
            case n => n
          }
      }
      sort(0)
    }
  }
}

abstract class RawReference(val data: Array[Byte]) extends Serializable {
  // we allow the access to the hashcode to be racey
  // if two threads compete, the result will be consistent
  // we don't need to sent the data down the wie as it is cheap enough to re-calculate after deserialisation
  // This hashCode need to be stable, please do not change the implementation, as we are using it for hash based sharding
  @transient private[this] var cachedHashcode = 0
  override def hashCode: Int = {
    var res = cachedHashcode
    if (res == 0) {
      res = MurmurHash3.bytesHash(data, 0)
      if (res == 0)
        res = -1
      cachedHashcode = res
    }
    res
  }

  /**
   * Calculate a hash hex for hash based sharding.
   * Underlying hash function must be kept stable
   * @return 8 hex chars in lower case
   */
  def hashHex: String = f"$hashCode%08x"

  override def equals(rhs: Any): Boolean = rhs match {
    case r: RawReference => (this.getClass == r.getClass) && Arrays.equals(data, r.data)
    case _               => false
  }

  final def longHash: Long = RawReference.hashing.hashBytes(data).asLong()

  override def toString: String = Base64.encodeBytes(data)

  def toUuid: UUID = UUIDConversions.bytesToUUID(data)
}

class StorableReference(d: Array[Byte]) extends RawReference(d)

object StorableReference {
  def fromString(rep: String): StorableReference = new StorableReference(RawReference.stringToBytes(rep))
}

private[optimus] final class StorableReferenceWrapper(val ref: StorableReference) {
  override def hashCode(): Int = ref.hashCode
  override def equals(obj: Any): Boolean = obj match {
    case that: StorableReferenceWrapper => Arrays.equals(ref.data, that.ref.data)
    case _                              => false
  }
}

final case class InvalidRawReferenceException(msg: String) extends IllegalArgumentException(msg) with RTExceptionTrait

object StrictDataSizeReference {
  // We have seen malformatted UUIDs in stored data that may affect clients
  // and/or the DAL server. By default, we no longer allow invalid references.
  // If this causes a problem, add the flag
  // -Doptimus.platform.permitInvalidReferences=true and restart the brokers.
  private[storable] val permitInvalidReferences = DiagnosticSettings
    .getBoolProperty("optimus.platform.permitInvalidReferences", false)
  protected val requiredReferenceBytes: Set[Int] = Set(0, 16)
}
sealed trait StrictDataSizeReference {
  import StrictDataSizeReference.permitInvalidReferences
  import StrictDataSizeReference.requiredReferenceBytes
  if (!permitInvalidReferences && !requiredReferenceBytes.contains(data.length)) {
    throw InvalidRawReferenceException(
      s"${this.getClass.getSimpleName} Given data has length ${data.length} byte(s), but length must be one of $requiredReferenceBytes.")
  }
  def data: Array[Byte]
}

/**
 * A reference to an entity, stable across temporal updates.
 */
sealed abstract class EntityReference protected (d: Array[Byte])
    extends StorableReference(d)
    with StrictDataSizeReference {
  def isTemporary: Boolean
  def getTypeId: Option[Int] = None

  override def equals(rhs: Any): Boolean = rhs match {
    case r: EntityReference => (this eq r) || Arrays.equals(data, r.data)
    case _                  => false
  }

}

// If unresolvedReference is set, it indicates that this FinalReference was constructed through resolution of the given
// TemporaryReference. Absence of the TemporaryReference might mean that the FinalReference was directly constructed in
// the DAL client (e.g. using the DAL unsafe API) or that the FinalReference was deserialized from backend storage where
// its lineage is not preserved. NB since this field is essentially only for use in the DAL server we don't bother to
// serialize it in the client/server protocol
private[optimus] sealed class FinalReference private[storable] (
    d: Array[Byte],
    val unresolvedReference: Option[TemporaryReference])
    extends EntityReference(d) {
  override def isTemporary = false
}

sealed trait TypedReference {
  def typeId: Int
}

private[optimus] final class FinalTypedReference private[storable] (
    d: Array[Byte],
    unresolvedReference: Option[TemporaryReference],
    val typeId: Int)
    extends FinalReference(d, unresolvedReference)
    with TypedReference {
  override def isTemporary = false
  override def getTypeId: Option[Int] = Some(typeId)
  // TODO (OPTIMUS-20613): Remove comment of toString method once typed refs is enabled in all DAL envs
  // override def toString = s"${Base64.encodeBytes(data)}:$typeId"
}

private[optimus] final class TemporaryReference private[storable] (d: Array[Byte]) extends EntityReference(d) {
  override def isTemporary = true
}

object EntityReference {
  def fresh: FinalReference = finalRef(UUIDGenerator.freshUuid(), None)
  def freshTemporary: TemporaryReference = temporary(UUIDGenerator.freshUuid())

  private[optimus] def freshFinal(tempRef: Option[TemporaryReference]): FinalReference =
    new FinalReference(UUIDGenerator.freshUuid(), tempRef)
  private[optimus] def freshFinalTyped(typeId: Int, tempRef: Option[TemporaryReference]): FinalTypedReference =
    new FinalTypedReference(UUIDGenerator.freshUuid(), tempRef, typeId)

  def fromString(rep: String): EntityReference = new FinalReference(RawReference.stringToBytes(rep), None)
  def fromString(rep: String, typeId: Option[Int]): EntityReference = typeId match {
    case Some(t) => typedFromString(rep, t)
    case None    => fromString(rep)
  }
  def typedFromString(rep: String, typeId: Int): FinalTypedReference =
    new FinalTypedReference(RawReference.stringToBytes(rep), None, typeId)
  def temporaryFromString(rep: String): TemporaryReference = new TemporaryReference(RawReference.stringToBytes(rep))

  def apply(d: Array[Byte]): EntityReference = finalRef(d, None)
  def apply(d: Array[Byte], typeId: Option[Int]): FinalReference =
    typeId.map(t => finalTypedRef(d, t)).getOrElse(finalRef(d))

  def finalRef(d: Array[Byte], tempRef: Option[TemporaryReference] = None): FinalReference =
    new FinalReference(d, tempRef)
  def finalTypedRef(d: Array[Byte], typeId: Int, tempRef: Option[TemporaryReference] = None): FinalTypedReference =
    new FinalTypedReference(d, tempRef, typeId)

  def temporary(d: Array[Byte]): TemporaryReference = new TemporaryReference(d)
  def typedFromEref(eref: EntityReference, typeId: Int): FinalTypedReference = finalTypedRef(eref.data, typeId)
}

private[optimus] final case class EntityTimeSliceReference(
    val entityRef: EntityReference,
    val timeSliceNumber: Int,
    val isInfiniteTxtoAtCreation: Boolean)

/**
 * A reference to a specific bitemporal version of an entity.
 */
final class VersionedReference(d: Array[Byte]) extends RawReference(d) with StrictDataSizeReference {
  def isEmpty: Boolean = this == VersionedReference.Nil
}

object VersionedReference {
  def fresh = new VersionedReference(UUIDGenerator.freshUuid())
  def fromString(rep: String): VersionedReference = new VersionedReference(RawReference.stringToBytes(rep))
  val Nil = new VersionedReference(new Array[Byte](16))
  def apply(d: Array[Byte]) = new VersionedReference(d)
}

object BusinessEventReference {
  def fresh = new BusinessEventReference(UUIDGenerator.freshUuid())
  def fromString(rep: String): BusinessEventReference = new BusinessEventReference(RawReference.stringToBytes(rep))

  def fromString(rep: String, typeId: Option[Int]): BusinessEventReference =
    apply(RawReference.stringToBytes(rep), typeId)

  def typedFromString(rep: String, typeId: Int): TypedBusinessEventReference =
    typedRef(RawReference.stringToBytes(rep), typeId)
  def typedRef(d: Array[Byte], typeId: Int) = new TypedBusinessEventReference(d, typeId)
  def apply(d: Array[Byte], typeId: Option[Int]): BusinessEventReference =
    typeId.map(t => typedRef(d, t)).getOrElse(new BusinessEventReference(d))
  val Nil = new BusinessEventReference(new Array[Byte](16))
  def apply(d: Array[Byte]) = new BusinessEventReference(d)
}

sealed class BusinessEventReference(d: Array[Byte]) extends StorableReference(d) {
  def getTypeId: Option[Int] = None

  override def equals(rhs: Any): Boolean = rhs match {
    case r: BusinessEventReference => (this eq r) || Arrays.equals(data, r.data)
    case _                         => false
  }
}

private[optimus] final class TypedBusinessEventReference private[optimus] (d: Array[Byte], val typeId: Int)
    extends BusinessEventReference(d)
    with TypedReference {
  override val getTypeId: Option[Int] = Some(typeId)
  // TODO (OPTIMUS-20613): Remove comment of toString method once typed refs is enabled in all DAL envs
  // override def toString = s"${Base64.encodeBytes(data)}:$typeId"
}

/**
 * A CMID -- exposed, user-set stable reference to an entity or event
 */
object CmReference {
  def apply(uuid: UUID): CmReference = {
    apply(RawReference.uuidToBytes(uuid))
  }

  def apply(data: Array[Byte]): CmReference = {
    new CmReference(data)
  }

  def fromString(rep: String): CmReference = new CmReference(RawReference.stringToBytes(rep))
  val Nil = new CmReference(new Array[Byte](16))
}

final class CmReference(d: Array[Byte]) extends StorableReference(d)

object AppEventReference {
  def fresh = new AppEventReference(UUIDGenerator.freshUuid())

  def fromString(rep: String): AppEventReference = {
    val data = Base64.decode(rep, Base64.DONT_GUNZIP)
    new AppEventReference(data)
  }
  val Nil = new AppEventReference(new Array[Byte](16))
}

final class AppEventReference(d: Array[Byte]) extends StorableReference(d)

final class LinkageReference(d: Array[Byte]) extends StorableReference(d)

object LinkageReference {
  def fresh = new LinkageReference(UUIDGenerator.freshUuid())
  def fromString(rep: String): LinkageReference = new LinkageReference(RawReference.stringToBytes(rep))
}

// Following class is used by test only, do not attempt to use it in broker code.
private[optimus] sealed class ForTestsOnlyEref(d: Array[Byte], callCounter: AtomicInteger)
    extends FinalReference(d, None) {
  override def isTemporary = true

  override def equals(rhs: Any): Boolean = {
    callCounter.incrementAndGet()
    false
  }
}
